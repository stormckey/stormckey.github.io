---
render_macros: false
---
# Shell Notes (revisited)

!!! abstract "一个离散的知识列表"

## 基础知识
### 内置变量/特殊变量

!!! tip ""
    === "$0"
        当前脚本的名称。对于被执行的脚本，它是脚本文件的路径和名称。
    === "$1, $2, $3, ..."
        位置参数变量，表示脚本或函数的参数。$1 表示第一个参数，$2 表示第二个参数，依此类推。
    === "$@"
        表示所有位置参数的列表。在脚本中，可以使用"$@"将所有位置参数作为一个参数传递给其他命令或函数。
    === "$#"
        表示位置参数的数量。
    === "$?"
        上一个命令的退出状态。如果命令成功执行，则其值为 0，否则为非零值。
    === "$$"
        当前脚本的进程 ID（PID）。
    === "$USER"
        当前用户的用户名。
    === "$HOME"
        当前用户的主目录路径。
    === "$PWD"
        当前工作目录的路径。
    === "$HOSTNAME"
        当前主机的主机名。
    === "$RANDOM"
        一个随机整数。
    === "$IFS"
        内部字段分隔符，用于指定由哪个字符分割输入数据的字段。默认情况下，它包含空格、制表符和换行符。
    === "$PATH"
        一个由冒号分隔的目录列表（环境变量），shell 在其中查找命令。

### 重定向

!!! tip ""
    === ">"
        将命令的标准输出重定向到文件。如果文件不存在，则会创建该文件；如果文件已存在，则会覆盖文件内容。
    === ">>"
        将命令的标准输出追加到文件的末尾。如果文件不存在，则会创建该文件。
    === "<"
        将文件的内容作为命令的标准输入。
    === "2>"
        将命令的标准错误输出重定向到文件。
    === "2>>"
        将命令的标准错误输出追加到文件的末尾。
    === "&>或&>>"
        将命令的标准输出和标准错误输出合并重定向到文件。

### 文件权限

!!! tip ""
    === "文件类型"
        -：普通文件
        d：目录
        l：符号链接（软链接）
        c：字符设备文件
        b：块设备文件
        s：套接字（socket）文件
        p：命名管道（FIFO）文件
    === "权限"
        r：读取权限
        w：写入权限
        x：执行权限
    === "权限字符串"
        由 10 个字符组成，第一个字符表示文件类型，后面三个字符表示文件所有者的权限，再后面三个字符表示文件所属组的权限，最后三个字符表示其他用户的权限。
        例如，-rw-r--r--表示普通文件，文件所有者具有读取和写入权限，文件所属组和其他用户具有读取权限。
    === "权限数字"
        由三个八进制数字组成，每个数字表示文件所有者、文件所属组和其他用户的权限。
        每个数字的计算方法是将对应的三个权限转换为八进制数拼接起来。
        例如，-rw-r--r--对应的权限数字为 644，-rwxr-xr-x 对应的权限数字为 755。
    === "权限修改"
        `chmod`：用于更改文件或目录的权限。可以使用数字表示法（如 chmod 755 file.txt）或符号表示法（如 chmod u+x file.txt）来修改权限。
        `chown`：用于更改文件或目录的所有者。
        `chgrp`：用于更改文件或目录的所属组。
        `umask`：设置新创建文件和目录的默认权限掩码。

### 文件操作

!!! tip ""
    === "`tee`"
        ```
        command | tee [OPTION]... [FILE]...
        ```
        `tee`是一个常用的命令行工具，用于从标准输入读取数据并将其同时输出到标准输出和指定的文件中。
        常用选项包括：
        -a：以追加模式将输出附加到文件中，而不是覆盖文件内容。
        -i：忽略中断信号（SIGINT），即使收到中断信号也继续运行。
        -p：使用原始数据块大小，而不是按行缓冲输出。
        -u：禁用输出缓冲区，立即将数据写入文件。
    === "`touch`"
        ```
        touch [OPTION]... FILE...
        ```
        创建一个空文件，或者更新已存在文件的最后更改时间。
        常用选项包括：
        -a：仅更改访问时间。
        -c：仅在文件不存在时才创建文件。
        -d：使用指定的日期时间，而不是当前时间。
        -m：仅更改修改时间。
        -r：使用指定文件的日期时间，而不是当前时间。
        -t：使用指定的日期时间，而不是当前时间。
    === "`cat`"
        ```
        cat [OPTION]... [FILE]...
        ```
        将文件的内容输出到标准输出。
        常用选项包括：
        -n：输出行号。
        -b：输出行号，但不对空行编号。
        -s：将连续的空行压缩成一个空行。
    === "`cp`"
        ```
        cp [OPTION]... SOURCE... DIRECTORY
        cp [OPTION]... SOURCE... DEST
        cp [OPTION]... -t DIRECTORY SOURCE...
        ```
        将文件或目录复制到指定的目录中，或者将文件或目录复制到指定的文件中。
        常用选项包括：
        -a：保留文件的所有属性，递归复制目录。
        -i：在覆盖文件之前提示用户确认。
        -r：递归复制目录。
        -u：仅在源文件的修改时间比目标文件的修改时间较新时才复制。
        -v：显示复制的进度。
    === "`mv`"
        ```
        mv [OPTION]... SOURCE... DIRECTORY
        mv [OPTION]... SOURCE... DEST
        ```
        将文件或目录移动到指定的目录中，或者将文件或目录重命名。
        常用选项包括：
        -i：在覆盖文件之前提示用户确认。
        -u：仅在源文件的修改时间比目标文件的修改时间较新时才移动。
        -v：显示移动的进度。
    === "`rm`"
        ```
        rm [OPTION]... FILE...
        ```
        删除文件或目录。
        常用选项包括：
        -f：强制删除文件，不提示用户确认。
        -i：在删除文件之前提示用户确认。
        -r：递归删除目录。
        -v：显示删除的进度。
    === "`ln`"
        ```
        ln [OPTION]... [-T] TARGET LINK_NAME
        ln [OPTION]... TARGET
        ln [OPTION]... TARGET... DIRECTORY
        ln [OPTION]... -t DIRECTORY TARGET...
        ```
        创建硬链接或符号链接。
        常用选项包括：
        -s：创建符号链接。
        -v：显示创建链接的进度。
    === "`mkdir`"
        ```
        mkdir [OPTION]... DIRECTORY...
        ```
        创建目录。
        常用选项包括：
        -m：设置目录的权限。
        -p：递归创建目录。
        -v：显示创建目录的进度。
    === "`rmdir`"
        ```
        rmdir [OPTION]... DIRECTORY...
        ```
        删除空目录。
        常用选项包括：
        -p：递归删除目录。
        -v：显示删除目录的进度。
    === "`find`"
        ```
        find [OPTION]... [PATH...] [EXPRESSION]
        ```
        在指定的目录中查找文件。
        常用选项包括：
        -name：按照文件名查找。
        -type：按照文件类型查找。
        -size：按照文件大小查找。
        -perm：按照文件权限查找。
        -exec：对查找到的文件执行指定的命令。
    === "`grep`"
        ```
        grep [OPTION]... PATTERN [FILE]...
        ```
        在文件中查找匹配的字符串。
        常用选项包括：
        -i：忽略大小写。
        -v：反向匹配。
        -n：输出行号。
        -c：输出匹配的行数。
        -r：递归查找。
    === "alias"
        ```
        alias [OPTION]... [NAME[=VALUE]]...
        ```
        创建命令别名。
        常用选项包括：
        -p：显示所有别名。
        -r：删除指定的别名。


## 脚本语法

### SheBang

Bash 脚本通常以 shebang 作为脚本文件的第一行，指定要用于解释脚本的解释器。常见的 shebang 为#!/bin/bash，表示使用 Bash 解释器解释脚本。
!!! tip "环境变量路径"
    如果要在脚本中使用 shebang，最好使用`#!/usr/bin/env bash`，这样可以避免使用绝对路径，而是使用环境变量中的路径。
### 变量

Bash 脚本中的变量不需要声明，直接使用即可。变量名和等号之间不能有空格，等号后面的值不能使用空格包围。变量名一般使用大写字母，但是不是必须的。

### 命令替换

命令替换用于将命令的输出结果赋值给变量。命令替换的语法有两种：

- \`command\`
- $(command)

### 进程替换

进程替换用于将命令的输出结果作为另一个命令的参数。进程替换的语法为`<(command)`。
可以将进程替换看作是命令替换的特殊形式，命令替换将命令的输出结果赋值给变量，而进程替换将命令的输出结果作为另一个命令的参数。

例如：`files=$(ls)`

### 花括号扩展

花括号扩展用于生成一个字符串列表。花括号扩展的语法为`{string1,string2,...}`。

例如：`echo {1..10}`

花括号扩展还可以进行笛卡尔积运算，语法为`{string1,string2,...}{string1,string2,...}`。

### 通配符

通配符用于匹配文件名。常见的通配符包括：

- `*`：匹配任意数量的任意字符。
- `?`：匹配任意一个字符。
- `[characters]`：匹配任意一个属于字符集中的字符。
- `[!characters]`：匹配任意一个不属于字符集中的字符。
- `[[:class:]]`：匹配任意一个属于指定字符类中的字符。
- `[^class]`：匹配任意一个不属于指定字符类中的字符。
- `[x-y]`：匹配任意一个属于指定范围中的字符。
- `[^x-y]`：匹配任意一个不属于指定范围中的字符。
- `[:alnum:]`：匹配任意一个字母或数字。
- `[:alpha:]`：匹配任意一个字母。
- `[:blank:]`：匹配空格或制表符。
- `[:digit:]`：匹配任意一个数字。
- `[:lower:]`：匹配任意一个小写字母。
- `[:upper:]`：匹配任意一个大写字母。
- `[:space:]`：匹配任意一个空白字符。
- `[:punct:]`：匹配任意一个标点符号。
- `[:word:]`：匹配任意一个字母、数字或下划线。
- `[:xdigit:]`：匹配任意一个十六进制数字。
- `[:graph:]`：匹配任意一个图形字符。
- `[:print:]`：匹配任意一个可打印字符。
- `[:cntrl:]`：匹配任意一个控制字符。
- `[:ascii:]`：匹配任意一个 ASCII 字符。

### 算术运算

Bash 脚本中的算术运算使用`$((expression))`语法，例如：`echo $((1+1))`

### 逻辑运算

Bash 脚本中的逻辑运算使用`&&`、`||`和`!`，例如：`[ -d /tmp ] && echo "Directory exists"`

### 条件判断

Bash 脚本中的条件判断使用`if`语句，语法如下：

```
if [[ condition ]]; then
    #statements
elif [[ condition ]]; then
    #statements
else
    #statements
fi
```

### 循环

Bash 脚本中的循环使用`for`和`while`语句，语法如下：

```
for (( i = 0; i < 10; i++ )); do
    #statements
done

for i in {1..10}; do
    #statements
done

for i in $(ls); do
    #statements
done

while [[ condition ]]; do
    #statements
done
```

### 函数

Bash 脚本中的函数使用`function`语句，语法如下：

```
function name {
    #statements
}
```

### 数组

Bash 脚本中的数组使用`array=(element1 element2 element3)`语法，例如：`array=(1 2 3)`
数组元素使用`array[index]`语法访问，例如：`echo ${array[1]}`
数组长度使用`${#array[@]}`语法获取，例如：`echo ${#array[@]}`
数组元素使用`${array[@]:index:length}`语法获取，例如：`echo ${array[@]:1:2}`，这会获取数组中从第二个元素开始的两个元素
数组元素使用`${array[@]/pattern/string}`语法获取，例如：`echo ${array[@]/2/4}`，这会将数组中的所有 2 替换为 4


### 字符串

Bash 脚本中的字符串使用`'string'`或者`"string"`语法，例如：`echo 'Hello World!'`
字符串长度使用`${#string}`语法获取，例如：`echo ${#string}`
字符串使用`${string:position:length}`语法获取，例如：`echo ${string:1:2}`
字符串使用`${string/substring/replacement}`语法获取，例如：`echo ${string/Hello/Hi}`，这会将字符串中的第一个 Hello 替换为 Hi


### Here 文档

Here 文档用于将多行文本赋值给变量。

Bash 脚本中的 Here 文档使用`<<`语法，例如：
```
read -d '' string <<EOF
Hello
World!
EOF
echo "$string"
```
这会将 Hello World!赋值给变量 string

### Here 字符串

Bash 脚本中的 Here 字符串使用`<<<`语法，例如：`cat <<<"Hello World!"`

### Here 脚本

Bash 脚本中的 Here 脚本使用`<<-`语法，例如：
```
cat <<-EOF
    Hello
    World!
EOF
```

### 输入

Bash 脚本中的输入使用`read`语句
其参数包括：
- `-p`：提示符
- `-n`：读取的字符数
- `-t`：超时时间
- `-s`：不回显输入的字符
- `-a`：将输入赋值给数组
- `-d`：分隔符
- `-r`：不对反斜杠进行转义
- `-e`：使用 Readline 库
- `-i`：默认值
- `-u`：输入的文件描述符

例如：
```
read -p "Enter your name: " name
echo "Hello $name"
```
